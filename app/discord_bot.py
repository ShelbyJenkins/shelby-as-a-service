import os
import random
import logging
import traceback
from dotenv import load_dotenv

import discord
from discord.ext import commands

from logger import setup_logger
from agents.async_shelby_agent import ShelbyAgent

logger = setup_logger('discord_bot', 'discord_bot.log', level=logging.DEBUG)

load_dotenv()

# Use this for local testing
# bot_token = os.getenv('SHELBY_SPRITE_DISCORD_TOKEN')
# channel_id = int(os.environ['SHELBY_SPRITE_DISCORD_CHANNEL_ID'])

# Use this for container deployments 
bot_token = os.getenv('DISCORD_TOKEN')
channel_id = int(os.environ['DISCORD_CHANNEL_ID'])


def create_bot():
    intents = discord.Intents.default()
    intents.guilds = True
    bot = commands.Bot(command_prefix=commands.when_mentioned_or("!"), intents=intents)
    return bot

bot = create_bot()

@bot.event
async def on_guild_join(guild):
    if not any(channel.name == channel_id for channel in guild.channels):
            logger.info(f'Leaving guild {guild.name} (ID: {guild.id}) due to missing channel.')
            await guild.leave()

@bot.event
async def on_ready():
    logger.info(f'Bot has logged in as {bot.user.name} (ID: {bot.user.id})')
    for guild in bot.guilds:
        if not any(channel.name == channel_id for channel in guild.channels):
            logger.info(f'Leaving guild {guild.name} (ID: {guild.id}) due to missing channel.')
            await guild.leave()
        
    print(f'Logged in as {bot.user} (ID: {bot.user.id})')
    print('------')
    channel = bot.get_channel(channel_id)
    if channel:
        random_animal = await get_random_animal()
        lower_animal = random_animal.lower()
        await channel.send(f'ima tell you about the {lower_animal}.')
    else:
        print(f'No channel with id {channel_id} found.')

@bot.event
async def on_message(message):
    print(message)
    print(message.content)
    if bot.user.mentioned_in(message):
        # don't respond to ourselves
        if message.author == bot.user.id:
            return
        if "rabbit" in message.content.lower():
            await message.channel.send(f'No, I will not tell you about the rabbits, {message.author.name}.')
            return
        # Must be in the correct channel
        if message.channel.id != channel_id:
            return
        
        query = message.content.replace(f'<@{bot.user.id}>', '').strip()
        
        # If question is too short
        if len(query.split()) < 4:
            logger.info('Message too short.')
            await message.channel.send(f"{message.author.name}, brevity is the soul of wit, but not of good queries. Please provide more details in your request.")
            return
        logger.info(f'Message received: {message.content} (From: {message.author.name})')
        # Create thread
        random_animal = await get_random_animal()
        thread = await message.create_thread(name=f"{random_animal} by {message.author.name}", auto_archive_duration=60)
        message_start = "Running query. Relax, chill, and vibe a minute."
        await thread.send(message_start)
        
        try:
            query_response = await agent.run_query(query)
        except Exception as e:
            tb = traceback.format_exc()
            logger.error(f"An error occurred: {str(e)}. Traceback: {tb}")
            await thread.send(f"An error occurred: {str(e)}. Traceback: {tb}")
            return  # or any other appropriate handling

        # Parse for discord and then respond
        parsed_reponse = parse_discord_markdown(query_response)
        logger.info(f'Parsed output: {parsed_reponse})')
        await thread.send(parsed_reponse)

        message_end = f"Generated by: {query_response['llm']}\nMemory not enabled. Has no knowledge of past or current queries.\nFor code see https://github.com/ShelbyJenkins/shelby-as-a-service."

        await thread.send(message_end)

def parse_discord_markdown(query_response):
    # Start with the answer text
    markdown_string = f"{query_response['answer_text']}\n\n"

    # Add the sources header if there are any documents
    if query_response['documents']:
        markdown_string += "**Sources:**\n"

        # For each document, add a numbered list item with the title and URL
        for doc in query_response['documents']:
            markdown_string += f"[{doc['doc_num']}] **{doc['title']}**: <{doc['url']}>\n"
    else:
        markdown_string += "No related documents found.\n"
  
    return markdown_string

async def get_random_animal():
    animals_txt_path = os.path.join('data', 'animals.txt')
    with open(animals_txt_path, 'r') as file:
        animals = file.readlines()
    return random.choice(animals).strip().lower()

if __name__ == "__main__":
    agent = ShelbyAgent()
    # Runs the bot through the asyncio.run() function built into the library
    bot.run(bot_token)



