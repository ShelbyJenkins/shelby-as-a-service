import logging
from typing import Any, Optional, Type

import context_index.doc_index as doc_index_models
from context_index.doc_index.doc_index_templates import DocIndexTemplates
from context_index.index_base import IndexBase
from services.database.database_service import DatabaseService
from services.document_loading.document_loading_service import DocLoadingService
from services.embedding.embedding_service import EmbeddingService
from services.text_processing.ingest_processing.ingest_processing_service import (
    IngestProcessingService,
)
from services.text_processing.text_utils import check_and_handle_name_collision
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy.orm import Session


class DocIndexBase(IndexBase):
    doc_index_model_instance: doc_index_models.DocIndexModel
    session: Session
    write_session: Optional[Session] = None
    context_template: doc_index_models.DocIndexTemplateModel

    @staticmethod
    def open_session():
        DocIndexBase.session = IndexBase.indexbase_open_session(
            DocIndexBase.doc_index_model_instance
        )

    @staticmethod
    def close_session():
        IndexBase.indexbase_close_session(DocIndexBase.session)

    @staticmethod
    def commit_session():
        IndexBase.indexbase_commit_session(DocIndexBase.session)

    @staticmethod
    def open_write_session() -> Session:
        DocIndexBase.close_session()
        DocIndexBase.write_session = IndexBase.indexbase_open_write_session(
            DocIndexBase.doc_index_model_instance
        )
        return DocIndexBase.write_session

    @staticmethod
    def close_write_session():
        IndexBase.indexbase_close_write_session(DocIndexBase.write_session)
        DocIndexBase.open_session()

    @staticmethod
    def commit_write_session():
        IndexBase.indexbase_commit_session(DocIndexBase.write_session)

    @property
    def domain_names(self) -> list:  # Can't type this due to Gradio issue
        return [domain.name for domain in DocIndexBase.doc_index_model_instance.domains]

    @property
    def source_names_in_doc_index(self) -> list:
        return [
            name[0] for name in DocIndexBase.session.query(doc_index_models.SourceModel.name).all()
        ]

    @property
    def index(self) -> doc_index_models.DocIndexModel:
        return DocIndexBase.doc_index_model_instance

    @property
    def domain(self) -> doc_index_models.DomainModel:
        if getattr(self.index, "current_domain", None) is None:
            raise Exception(f"{self.index} has no domain.")
        return self.index.current_domain

    @property
    def source(self) -> doc_index_models.SourceModel:
        if getattr(self.domain, "current_source", None) is None:
            raise Exception(f"{self.domain} has no source.")
        return self.domain.current_source

    def get_provider_instance_model_from_service_name(
        self,
        service_name: str,
        provider_name: str,
        parent_domain_or_source: Optional[
            doc_index_models.DomainModel | doc_index_models.SourceModel
        ] = None,
    ) -> Any:
        # Used for UI components generated by services
        if not parent_domain_or_source:
            if service_name == DatabaseService.CLASS_NAME:
                provider_model = self.get_index_model_instance(
                    list_of_instances=self.index.doc_dbs, name=provider_name
                )
            else:
                raise ValueError(f"service_name must be {DatabaseService.CLASS_NAME}")
        else:
            if service_name == DocLoadingService.CLASS_NAME:
                provider_model = self.get_index_model_instance(
                    list_of_instances=parent_domain_or_source.doc_loaders, name=provider_name
                )

            elif service_name == IngestProcessingService.CLASS_NAME:
                provider_model = self.get_index_model_instance(
                    list_of_instances=parent_domain_or_source.doc_ingest_processors,
                    name=provider_name,
                )
            else:
                raise ValueError(
                    f"service_name must be {DocLoadingService.CLASS_NAME}, {IngestProcessingService.CLASS_NAME}"
                )
        if provider_model is None:
            raise ValueError(f"provider_model {provider_model} not found")
        return provider_model
